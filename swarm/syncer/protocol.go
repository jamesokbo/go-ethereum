// Copyright 2018 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package syncer

import (
	"context"
	"crypto/rand"

	"github.com/ethereum/go-ethereum/p2p"
	"github.com/ethereum/go-ethereum/p2p/enode"
	"github.com/ethereum/go-ethereum/swarm/storage"
	// "github.com/ethereum/go-ethereum/swarm/pss"
)

// dispatcher makes sure newly stored chunks make it to the neighbourhood where they
// can be retrieved, i.e. to nodes whose area of responsibility includes the chunks address
// it gathers proof of custody responses validates them and signal the chunk is synced
type dispatcher struct {
	baseAddr  storage.Address      // base address to use in proximity calculation
	chunkC    chan *chunkMsg       // outgoing queue for chunk messages
	receiptsC chan storage.Address // outgoing queue for synced chunk addresses
	quitC     chan struct{}        // channel to close when cancelling syncer
	prover    Prover               // prover interface to verify proofs
}

// Prover generates the proof for the data and a challenge and verifies a proof
// fot a challenge
type Prover interface {
	// verify checks the POC proof
	Verify(proof, addr []byte, peer enode.ID) error
	// getProof provides a proof for a challenge on the data
	GetProof(data, challenge []byte) []byte
}

// newDispatcher constructs a new node-wise dispatcher
func newDispatcher(baseAddr storage.Address, prover Prover) *dispatcher {
	return &dispatcher{
		baseAddr:  baseAddr,
		chunkC:    make(chan *chunkMsg),
		receiptsC: make(chan storage.Address),
		quitC:     make(chan struct{}),
		prover:    prover,
	}
}

// close closes the dispatcher
func (s *dispatcher) close() {
	close(s.quitC)
}

// sendChunk is called on incoming chunks that are to be synced
func (s *dispatcher) sendChunk(ch storage.Chunk) {
	challenge := newChallenge()
	// TODO: proofs for the challenge should be generated and saved
	msg := &chunkMsg{
		Origin:    s.baseAddr,
		Addr:      ch.Address()[:],
		Data:      ch.Data(),
		Challenge: challenge,
	}
	select {
	case s.chunkC <- msg:
	case <-s.quitC:
	}
}

// newChallenge creates a random nonce;
// even without POC it is important otherwise resending a chunk is deduplicated by pss
func newChallenge() []byte {
	buf := make([]byte, 32)
	t := 0
	for t < len(buf) {
		n, _ := rand.Read(buf[t:])
		t += n
	}
	return buf
}

// chunkMsg is the message construct to send chunks to their local neighbourhood
type chunkMsg struct {
	Addr      []byte
	Data      []byte
	Origin    []byte
	Challenge []byte
}

// proofMsg is a proof of custody response to a challenge on a chunk
// signed by a node in the local neighbourhood of the chunk address
// TODO: it is currently a place holder used as notification only
type proofMsg struct {
	Addr  []byte
	Proof []byte
}

type proofResponse struct {
	to  []byte
	msg *proofMsg
}

// handleProof is called by the pss dispatcher on proofTopic msgs
// after decoding the POC msg and validating, it calls the chunk address to receiptsC
func (s *dispatcher) handleProof(msg *proofMsg, p *p2p.Peer) error {
	err := s.prover.Verify(msg.Proof, msg.Addr, p.ID())
	if err != nil {
		// just ignore invalid POC msgs, swallow error
		// FIXME: potential DDOS? if this PSS topic is free
		return nil
	}
	select {
	case s.receiptsC <- msg.Addr:
	case <-s.quitC:
	}
	return nil
}

// storer makes sure that chunks sent to them that fall within their area of responsibility
// are stored and synced to their nearest neighbours and issue a proof of custody response
// to the originator the proof is generated by the prover using the chunk data and a challenge
type storer struct {
	proofC     chan *proofResponse // outgoing queue for poc responses
	chunkStore storage.ChunkStore  // store to put chunks in, and retrieve them
	quitC      chan struct{}       // channel to close when cancelling syncer
	prover     Prover
}

// newStorer constructs a new node-wise storer
func newStorer(chunkStore storage.ChunkStore, prover Prover) *storer {
	s := &storer{
		proofC:     make(chan *proofResponse),
		quitC:      make(chan struct{}),
		chunkStore: chunkStore,
		prover:     prover,
	}
	return s
}

// close closes the dispatcher
func (s *storer) close() {
	close(s.quitC)
}

// handleChunk is called by the pss dispatcher on chunkTopic msgs
// only if the chunk falls in the nodes area of responsibility
func (s *storer) handleChunk(msg *chunkMsg, p *p2p.Peer) error {
	// TODO: double check if it falls in area of responsibility
	ch := storage.NewChunk(msg.Addr, msg.Data)
	err := s.chunkStore.Put(context.TODO(), ch)
	if err != nil {
		return err
	}
	// TODO: check if originator or relayer is a nearest neighbour then return
	// otherwise send back POC proof response to challenge
	proof := s.prover.GetProof(msg.Data, msg.Challenge)
	r := &proofResponse{
		to: msg.Origin,
		msg: &proofMsg{
			Addr:  msg.Addr,
			Proof: proof,
		},
	}

	select {
	case s.proofC <- r:
	case <-s.quitC:
	}
	return nil
}
